package com.zpf.Decorator;
/*
 *装饰者模式
 *定义：
 *  在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。
 *  它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。
 *
 *角色：
 *   抽象构件角色（Project）：给出一个接口，以规范准备接收附加责任的对象。
 *  具体构件角色（Employe）：定义一个将要接收附加责任的类。
 *   装饰角色（Manager）：持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。
 *  具体装饰角色（ManagerA、ManagerB）：负责给构件对象“贴上”附加的责任。
 */
//定义一个人类接口
public interface Phone {

     void  call();

}

/**优点：
 1，使用装饰者模式比使用继承更加灵活，因为它选择通过一种动态的方式来扩展一个对象的功能，
 在运行时可以选择不同的装饰器，从而实现不同的行为。
 2，通过使用不同的具体装饰类以及这些装饰类的排列组合，
 可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，
 得到功能更为强大的对象。
 3，具体构件类与具体装饰类可以独立变化，他能是低耦合的。
 用户可以根据需要来增加新的具体构件类和具体装饰类，
 在使用时再对其进行各种组合，原有代码无须改变，符合“开闭原则”。

 缺点：
 1，会产生很多的小对象，增加了系统的复杂性
 2，这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，
 排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

 装饰者与适配者模式的区别：
 1，适配器模式主要用来兼容那些不能在一起工作的类，使他们转化为可以兼容目标接口，
 虽然也可以实现和装饰者一样的增加新职责，但目的不在此。
 装饰者模式主要是给被装饰者增加新职责的。
 2，适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。
 装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。
 3，适配器是知道被适配者的详细情况的（就是那个类或那个接口）。
 装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。

 装饰者和继承的区别：
 继承：
 　　优点：代码结构清晰，而且实现简单
 　　缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。
 装饰者：
 　　优点：内部可以通过多态技术对多个需要增强的类进行增强
 缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。

 使用场景：
 1，需要扩展一个类的功能，或给一个类添加附加职责。
 2，需要动态的给一个对象添加功能，这些功能可能不明确或者暂时的，可以随时很方便的动态撤销掉。
 3，需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
 4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，
 为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
 另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
 */

